---

title: 'Lecture for Model View Controller'
publishedAt: '2022-08-29'
description: Organizational paradigms for efficiency in programming
seoDescription: This is the seoDescription for this markdown file.
category: 'Technology'
author:
  {
    name: 'Megan Matanda',
    image: 'https://media-exp1.licdn.com/dms/image/C4E03AQHOlcjIeSs7Hw/profile-displayphoto-shrink_200_200/0/1656079264419?e=1665014400&v=beta&t=iqNsDEnusO-SGUDunM-TC5ZJcMGGMq6Yn_xWwOVYXvE',
  }
image: '/images/pic9.png'
---

## Lecture on Model View Controller


Programming projects launched by companies are usually built by team groups. To increase the productivity, the quickness and efficiency, for these websites and web applications to be properly deployed online and exploited by customers and partners, patterns and specific paradigms had to be implemented, and are now required.

The purpose of integrating set of rules and conventions, are also to preserve an organized and standardized axis, that is readable, that can be easily debugged, and perfectly maintained by the the rest of the software engineer team.

The separation of concerns is actually a programming methodology that split the codebase into different components, and can also be observed in frontend, with HTML/CSS/Javascript. That architeture is indeed appliable in frontend, but also back in the server, where all the set of instructions and functionalities, are processed under the hood.

## MVC History

That paradigm invented in 1978 by the Norwegian computer engineer Trygve Reenskaug, was specifically created to encapsulate and abstract the backend code into different and specific sections, according to their roles and repsonsibilities. The MVC architecture purpose, was specifically funded
so the codebase remain standardized, organized, from production to its online deployment. The MVC beauty resides in its capability of modifiying one of these divided portions logic, **without** disrupting any of the rest of the project.

# What does MVC mean exactly ?

¬∑         La View (ou les vues) repr√©sente l‚Äôinterface graphique √† livrer au client qui en fait la requ√™te. Avoir le code li√© √† l‚Äôinterface isol√© de la logique m√©tier ou des donn√©es permet de faire des modifications √† l‚Äôinterface graphique sans avoir √† se soucier de casser du code m√©tier ou la structure des donn√©es.
¬∑         Le(s) Controller(s) sont au c≈ìur de la logique m√©tier de votre application. Ils se situent entre les vues et le model. Les requ√™tes qu‚Äôun client va faire depuis l‚Äôinterface graphique, la view, vont √™tre dirig√©es vers un controller qui sera en charge de manipuler les donn√©es dont il a besoin avec la brique Model, la traiter suivant le besoin m√©tier, puis ordonner √† la view de r√©pondre au client avec les bons √©l√©ments.

- Model: the model represents the data structure, and contain all the information, data, pictures etc, stored, that can be rendered into the visible section by the user, if needed. The model can either be defined by a relational database structures such as SQL, or either by a non-relational object oriented database such as Mongodb. 
While the MVC paradigm is pursposely designed to interact with each other, the model section does not communicate directly with the View, the user interface: the reason is to facilitate any changes like adding new fancy features to the front end section (View), without having to go through the troubleshooting phases. It is easier, more manageable and maintanable,

- View: is the graphic interface visible by the clientside. Every requests are sent from the view to the backend. According to the nature request, the model branch where are all the data are nested, can be summoned, if the user requested a specific information to be retrieved from the database. View is directly connected with the Controllers.

- Controllers : are the essential segment of the MVC pattern and the programming process. They connect the view requests with the model databases. The controllers role is to redirect the type of requests (Get, Post, Put, Delete) sent from view, the  clientside browser, to the appropriate branch. 

         ‚Ä¢The Router: the router is the first backend server layer, its role is to filter the requests recieved on the clientside from view. The router functionality is to listen to the specific URL/request, so it can properly identify which CRUD : Create/Post, Read/Get, Update,Put, Delete reques has been sent, so it can then redirect it to the adequate controller.

         ‚Ä¢The Controller: which is the MVC backend programming component, will then receive the request directed accordingly by the router from the view, and will then match that request to the adequate controller functionality, so it can respond back to the clientside, with the suitable elements. The controller responsibility is to execute an action required by the UI via the router.
      Note: According to the nature of the req, the controller can either directly execute an action to view (ex: refresh a page), either go through models to collect/retrieve required data.


# Conclusion

These three architectural patterns, help organize and visualize how the project works underneath the hood. It gives us a better understanding of each of its component functionalities and their missions. The Model can be considered as a sort of a bucket, connecting the server with a database that stores all the informations and data needed for further requests.
 Mongodb is my favorite non-relational database, its specificity is that it assembles data into collections of document, that are array of objects prototype. The model branch regroups these specific files, that are duplicated thanks to Mongoose. Mongoose interface is convenient when you work with a team, because the data sotred in the model is accessible by the other software engineer
 without having to share the usernames and passwords. The other perks of Mongodb, is its data rendering flexibility: the schema functionality is a Mongodb specific configuration, that gives you the freedom 
 to define how you want your data to be displayed on the user interface. 

 Example:

 Todo.js
 
 /*
 
 // connect mongoose in the Todo file
 const mongoose = require('mongoose')

// invoke the schema functionality in Todo file, and gives you the liberty to create the your own collection with pair key values.
\ const TodoSchema = new mongoose.Schema({
  todo : {
    type: String,
    required: true,
  },
  completed: {
    type: Boolean,
    required: true,
  },
  userId: {
    type: String,
    required: true
  }
}) \

//will export the mongoose model in any file needed
module.exports = mongoose.model('Todo', TodoSchema) */

The code above, is a schema example, showing how a collection can be defined and rendered in the database. Here my Todo collection will contain a type with a string prototype, the status 'completed' and a boolean value, plus a value id as a string. Any categories can be configured in the schema it is up to the
web developer. And that is the beauty of Mongodb programming, the data customisation.  

 that will be rendered to front end templates (ejs, react, hug), so views can shw them in the front end. Controller connect the right req with the right controller so the actions requested can be executed and the browser can receive the  according response.


Votre code source qui √©tait simple et dans lequel vous vous retrouviez facilement devient un plat de spaghetti üçù ! Plus celui-ci grandit, plus il deviendra difficile d‚Äôajouter une fonctionnalit√© sans cr√©er un dysfonctionnement dans une autre d√©j√† existante. C‚Äôest ce qu‚Äôon appelle une r√©gression. Sans une organisation standard de votre codebase, d√©bugger deviendra une t√¢che longue et p√©nible. Collaborer avec un autre d√©veloppeur sur votre projet demandera une assistance constante de votre part.
C‚Äôest pour √©viter ces handicaps que le MVC a √©t√© mis en √©vidence et propos√© comme un pattern d‚Äôarchitecture.
En structurant une codebase avec l‚Äôarchitecture MVC vous lui apportez:
Une facilit√© pour retrouver les diff√©rents modules ou fonctions de votre code
Un d√©buggage plus rapide
Un gain de temps √† la modification ou ajout de nouvelles fonctionnalit√©s
Un confort pour le d√©veloppement, par vous-m√™me ou un futur collaborateur
Une s√©paration entre la logique m√©tier, les interfaces graphiques et la mod√©lisation des donn√©es de telle sorte √† ce que la modification de l‚Äôun ne casse pas l‚Äôautre
 
