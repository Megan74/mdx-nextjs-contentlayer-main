---

title: 'Lecture for Model View Controller'
publishedAt: '2022-08-29'
description: Organizational paradigms for efficiency in programming
seoDescription: This is the seoDescription for this markdown file.
category: 'Technology'
author:
  {
    name: 'Megan Matanda',
    image: 'https://media-exp1.licdn.com/dms/image/C4E03AQHOlcjIeSs7Hw/profile-displayphoto-shrink_200_200/0/1656079264419?e=1665014400&v=beta&t=iqNsDEnusO-SGUDunM-TC5ZJcMGGMq6Yn_xWwOVYXvE',
  }
image: '/images/pic9.png'
---

## Lecture on Model View Controller


Programming projects launched by companies are usually built by team groups. To increase the productivity, the quickness and efficiency, for these websites and web applications to be properly deployed online and exploited by customers and partners, patterns and specific paradigms had to be implemented, and are now required.

The purpose of integrating set of rules and conventions, are also to preserve an organized and standardized axis, that is readable, that can be easily debugged, and perfectly maintained by the the rest of the software engineer team.

The separation of concerns is actually a programming methodology that split the codebase into different components, and can also be observed in frontend, with HTML/CSS/Javascript. That architeture is indeed appliable in frontend, but also back in the server, where all the set of instructions and functionalities, are processed under the hood.

## MVC History

That paradigm invented in 1978 by the Norwegian computer engineer Trygve Reenskaug, was specifically created to encapsulate and abstract the backend code into different and specific sections, according to their roles and repsonsibilities. The MVC architecture purpose, was specifically funded
so the codebase remain standardized, organized, from production to its online deployment. The MVC beauty resides in its capability of modifiying one of these divided portions logic, **without** disrupting any of the rest of the project.

# What does MVC mean exactly ?

·         La View (ou les vues) représente l’interface graphique à livrer au client qui en fait la requête. Avoir le code lié à l’interface isolé de la logique métier ou des données permet de faire des modifications à l’interface graphique sans avoir à se soucier de casser du code métier ou la structure des données.
·         Le(s) Controller(s) sont au cœur de la logique métier de votre application. Ils se situent entre les vues et le model. Les requêtes qu’un client va faire depuis l’interface graphique, la view, vont être dirigées vers un controller qui sera en charge de manipuler les données dont il a besoin avec la brique Model, la traiter suivant le besoin métier, puis ordonner à la view de répondre au client avec les bons éléments.

- Model: the model represents the data structure, and contain all the information, data, pictures etc, stored, that can be rendered into the visible section by the user, if needed. The model can either be defined by a relational database structures such as SQL, or either by a non-relational object oriented database such as Mongodb. 
While the MVC paradigm is pursposely designed to interact with each other, the model section does not communicate directly with the View, the user interface: the reason is to facilitate any changes like adding new fancy features to the front end section (View), without having to go through the troubleshooting phases. It is easier, more manageable and maintanable,

- View: is the graphic interface visible by the clientside. Every requests are sent from the view to the backend. According to the nature request, the model branch where are all the data are nested, can be summoned, if the user requested a specific information to be retrieved from the database. View is directly connected with the Controllers.

- Controllers : are the essential segment of the MVC pattern and the programming process. They connect the view requests with the model databases. The controllers role is to redirect the type of requests (Get, Post, Put, Delete) sent from view, the  clientside browser, to the appropriate branch. 

         •The Router: the router is the first backend server layer, its role is to filter the requests recieved on the clientside from view. The router functionality is to listen to the specific URL/request, so it can properly identify which CRUD : Create/Post, Read/Get, Update,Put, Delete reques has been sent, so it can then redirect it to the adequate controller.

         •The Controller: which is the MVC backend programming component, will then receive the request directed accordingly by the router from the view, and will then match that request to the adequate controller functionality, so it can respond back to the clientside, with the suitable elements. The controller responsibility is to execute an action required by the UI via the router.
      Note: According to the nature of the req, the controller can either directly execute an action to view (ex: refresh a page), either go through models to collect/retrieve required data.


# Conclusion

These three architectural patterns, help organize and visualize how the project works underneath the hood. It gives us a better understanding of each of its component functionalities and their missions. The Model can be considered as a sort of a bucket, connecting the server with a database that stores all the informations and data needed for further requests.
 Mongodb is my favorite non-relational database, its specificity is that it assembles data into collections of document, that are array of objects prototype. The model branch regroups these specific files, that are duplicated thanks to Mongoose. Mongoose interface is convenient when you work with a team, because the data sotred in the model is accessible by the other software engineer
 without having to share the usernames and passwords. The other perks of Mongodb, is its data rendering flexibility: the schema functionality is a Mongodb specific configuration, that gives you the freedom 
 to define how you want your data to be displayed on the user interface. 



Example

 # Todo.js
 
 ```js index.js box=1[30:50]

 // connect mongoose database in the Todo.js file
 const mongoose = require('mongoose')

```
```js next.config.js focus=1:2,9
/* invoke the schema functionality in the Todo.js file, 
and gives you the liberty to create your own customized collection with key-pair values.*/
 const TodoSchema = new mongoose.Schema({
  todo : {
    type: String,
    required: true,
  },
  completed: {
    type: Boolean,
    required: true,
  },
  userId: {
    type: String,
    required: true
  }
}) 

/* will export the mongoose model in any files needed, 
and be called by the controller to be rendered in view as server response */
module.exports = mongoose.model('Todo', TodoSchema) 

```



The code above, is a schema example, that shows how a collection can be defined and rendered in the database. 

The Todo collection will contain a type with a string prototype, the status completed and a boolean value, plus a userId as a string. 
Any properties can be configured in the mongoose schema, it is up to the
web developer. And that is the beauty of Mongodb programming, the data customisation.  




 
